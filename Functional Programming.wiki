= Functional Programming =

[[MonadicDesignPatternsForTheWeb]]

== Points-free programming ==

Points-free programming style is to define functions withour ever making direct
reference to their arguments.

Example:
{{{
var sum = function(list)_{
    return reduce(add, 0, list);
}
// Transforms to
var sum = _.partial(reduce, add, 0);


// Different example
var propEq = function(prop, val) {
    return function(obj) {
        return obj[prop] === val;
    }
}

// Transforms to
var propEq = function(prop,val) {
    return compose(eq(val), get(prop));
}
}}}

=== Use-over function === 

`use(func).over(transformer1, ..., transformerN)` accepts N parameters, feeds 
them to the respective transformers  and then calls `func` using the results of 
all of these. 

{{{
var propEq = use(pipe).over(get, eq);
// ...
.then(filter(propEq('member', memberName)))
.then(reject(propEq('complete', true)))
}}}


== Transforming an array ==

Use `arr.map(pick['p1','p2' /*, ... */ ])`.


== Avoiding side-effects ==

Make any state changes that occur as a result of an action explicit by returning
them as a part of the result.
This can be achieved by returning a tuple or returning multiple values if the 
language supports it.

Example with implicit side-effects:
{{{
class Cafe {
    // This is not the original first step of the example.
    // The change made from the first step is that `Payments` are being
    // injected to allow testability.
    def buyCoffee(cc: CreditCard, p: Payments): Coffee = {
        val cup = new Coffee()
        // Still, we have to mock to test this, because it's an implicit side effect.
        p.charge(cc, cup.price)
        cup
    }

}
}}}

To make the state change explicit:
{{{
class Cafe {
    def buyCoffee(cc: CreditCard): (Coffee, Charge) = {
        val cup = new Coffee()
        // Now it is up to the caller to do something with the charge.
        // SRP is happy.
        // No mocks have to be injected because no side effects have to be
        // stubbed out.
        (cup, new Charge(cc, cup.price))
    }
}
}}}

A nice example is an approximation of Haskell's `IO` in Scala:
{{{
class IO[A](val apply: RealWorld => (A, RealWorld))
}}}

Where the `RealWorld` argument is the state of the world before the I/O and the
`(A, RealWorld)` result represents the result of the I/O and the state of the
world after performing this action.

Practically, this is represented as:
{{{
class IO[A](val apply: () => A)
}}}

How would `main` look as a pure function:
{{{
sealed trait RealWorld

abstract class Program {
    private val realWorld = new RealWorld {}

    final def main(args: Array[String]): Unit = {
        pureMain(args).apply()   
    }

    def pureMain(args: IndexedSeq[String]): IO[Unit]
}
}}}

Wrapping actions in `IO` is conceptually very similar to just delaying them.
The actual application of the action is being deferred to a point in code that
calls their `.apply()` method.
An `IO[A]` is just a lazy `A`.
