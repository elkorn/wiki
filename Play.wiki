= Play =
%toc

Using the `play` command, one can call the framework's functions (e.g.
`views.html.hello.render("Scala")` without having to run the server.
There is testability potential here, don't know yet how it all is wired up
though.

== Architecture ==

Based on the MVC model.
Play runs o JBoss Netty server (a non-blocking Java _New I/O_ -type server).
Play apps can satisfy the constraints of a REST-style architecture.
Resources can be identified by URLs (through routes) and manipulated by HTTP
methods.

=== Ways of app design ===

- *Database-centric*, where you start by defining the domain model with database entities and relations
    - A common approach in enterprise environments, which often view the data model as a fundamental representation of a business domain that will outlive any single software application.
- *URL-centric*, where you start by defining the application's HTTP interface. 
    - Once you have a solid design, you can add a user-interface layer on top of this HTTP interface, and add a model that backs the HTTP resources.
    - You can create a consistent public API for your application that’s more stable than either the physical data model represented by its model classes, or the user interface generated by its view templates.
    - Focus is applied to _resource-oriented architecture_.
- *UI-centric*, where you start by defining ways in which the user will interact with the application through its GUI.
    - Mockups play a driving role.

=== Configuration ===

Play uses the [[https://github.com/typesafehub/config|Typesafe config library]].
It is possible to modularize the config through using multiple `.conf` files.
Create a `db-default.conf`, containing your default DB connection information
and then use `include "db-default.conf"` in your main `application.conf` file.

"Overwriting" a JSON object in the `application.conf` will effectively merge its
properties with the original one, instead of truly overwriting it.

The configuration file format is specified by the
[[https://github.com/typesafehub/config/blob/master/HOCON.md|Human-Optimized Config Object Notation]].

Configuration can be overriden from the CLI by using `run -Ddb.default.url=xxx`
for single values or `run -Dconfig.file=xxx/xxx` for the whole config file.
A relative path can be used for configs residing within the project, an absolute
one has to be provided for external configuration files.

The `play.api.Configuration` class provides the API for accessing config
options.

The `play.api.Application.configuration` is the configuration instance
for the current application.

Example:

{{{
import play.api.Play.current
current.configuration.getString("db.default.url").map {
    databaseUrl => Logger.info(databaseUrl)
}

// You can also use getBoolean, getInt etc. - it's type-safe.
}}}

Configuration is structured hierarchically:

{{{
// Returns an Option[Configuration] object.
current.configuration.getConfig("db.default").map {
    databaseConfiguration =>
        databaseConfiguration.getString("driver").map(Logger.info(_))
        databaseConfiguration.getString("url").map(Logger.info(_))
}
}}}

Using custom entries (e.g. `application.revision`):

{{{
@import play.api.Play.current
<footer>
    Revision @current.configuration.getString("application.revision")
</footer>
}}}

=== Controller ===

Handles incoming HTTP requests and uses the model and view to build and return a
response.

Controller methods are called _actions_— Play’s architecture is in fact an MVC
variant called _action-based MVC_— so you can also think of a controller class
as a collection of action methods.

Group controllers by entity.

Don't define `var`s in controllers.
They should be stateless.

Each `Action` in Scala is a `Request[A] => Result` function, where `A` is the
request body type.

*Only import stuff from the* `play.api` *package*.


- `play.api.mvc.Cookie`— An HTTP cookie: a small amount of data stored on the client and sent with subsequent requests.
- `play.api.mvc.Request`— An HTTP request: HTTP method, URL, headers, body, and cookies
- `play.api.mvc.RequestHeader`— Request metadata: a name-value pair
- `play.api.mvc.Response`— An HTTP response, with headers and a body; wraps a Play Result
- `play.api.mvc.ResponseHeader`—Response metadata: a name-value pair


- `play.api.mvc.Action`—A function that processes a client Request and returns a Result
- `play.api.mvc.Call`—An HTTP request: the combination of an HTTP method and a URL
- `play.api.mvc.Content`—An HTTP response body with a particular content type
- `play.api.mvc.Controller`—A generator for Action functions
- `play.api.mvc.Flash`—A short-lived HTTP data scope used to set data for the next request
- `play.api.mvc.Result`—The result of calling an Action to process a Request,
- `play.api.mvc.Session`—A set of string keys and values, stored in an HTTP used to generate an HTTP response cookie

==== Action composition ====

To avoid code duplication, actions can be composed, since they are just
functions.
It's a decorator pattern.

Example:
{{{
def list =
    Authenticated {
        Cached {
            Action {
                // Process request...
            }
        }
    }
}}}

`Authenticated` action is being passed to `Cached` as a parameter, which in turn
is being passed to the main `Action` that is to constitute the actual work to be
done.


==== Parameter Binding ====

Play uses binding concepts similar to those in ASP .NET MVC.

Will be discussed in chapter 7.

=== View ===

Combines dynamic model data with view templates.

If you have high performance requirements for serving static content, the best
approach is probably to use a cache or load balancer in front of Play,
instead of avoiding serving the files using Play in the first place.


=== Model ===

The application's domain-specific data and logic.
Communicates with storage through _Persistence API_.

It is beneficial to represent the model with Scala case classes.
They can be serialized by the Persistence API.

Play uses the the [[http://workwithplay.com/blog/2013/05/08/persist-data-with-anorm/|Anorm]] persistence library, but it's not a requirement.
Other ones, such as [[http://www.scalatra.org/2.2/guides/persistence/slick.html|Slick]], can be used.

==== Slick ====
[[http://www.scalatra.org/2.2/guides/persistence/slick.html|Slick]] is intended as the go-to Scala persistence API for relational DB access.
It acts as a kind of ORM by using built-in Scala language features.

Examples:

- Mapping a database table to a `Product` DAO:
{{{
object Product extends Table[(Long, String, String)]("products") {
    def ean = column[Long]("ean", O.PrimaryKey)
    def name = column[String]("name")
    def description = column[String]("description")

    // The projection that defines the columns in the "Table" definition.
    def * = ean ~ name ~ description
}
}}}
- defining a query on a `Product` object:
{{{
val products = for {
    product <- Product.sortBy(product => product.name.asc)
} yield (product)
}}}
To execute the query, you can use the query to generate a list of products in a
database session:
{{{
val url = "jdbc:postgresql://localhost/slick?user=slick&password=slick"
Database.forURL(url, driver = "org.postgresql.Driver") withSession {
    val productList = products.list
}
}}}

== Jobs ==

Akka is integrated, so long-running jobs can be scheduled for `Actor`s to
perform.
See the `simple-app` example for code.

== Modularization ==

Play is modular - there are core modules, custom modules and 3rd party modules.

Examples of 3rd party modules:
- _Deadbolt_ - role-based authorization
- _Groovy templates_ - Alternative to Scala templates
- _PDF_ - PDF output based on HTML templates
- _Redis_ - Redis cache implementation
- _Sass_ - Sass compilation support

The main Play application should be oriented on the domain model and business
logic.
Everything else should be extracted to custom modules. (for SRP, testability,
maintainability etc.)
i
*Example: adding commenting functionality to an application for managing product stocks in a warehouse network.*
This functionality (as well as the related data) is somewhat independent from
the domain and has a public interface (UI / API) that's separate from the rest
of the app.

Related features:
- Persistent model classes for comment storage
- A UI on the products page for CRUDing comments
- A controller, providing an HTTP API for adding and viewing comments

For that, you'd create a new, separate `comments` module, add it as an app
dependency and finally move the relevant code to the module. This assumes that
you have already coded up the comments in the main app and want to refactor.
You can also go module-first, always creating separate modules for different
functionalities and adding to the main application only when absolutely
necessary.

=== How to connect modules to the domain ===

E.g. the obvious model design for product comments includes a direct reference
from a comment to a product it relates to.
Such a design would of course make the comments module dependent on the domain
model, a trait you strive to avoid.
The solution is to make a weaker link from comments to products, using the app's
HTTP API. Instead of linking comments directly to the products model, you can
link comments to an arbitrary application URL, such as a product's details page
URL.

As long as you identify products by clean, stateless URLs for their details
pages, it's enough to comment on a page instead of a product.

A similar issue arises in the controller layer when you want to acquire the
comments for a given product to render them inline within the view template.
The solution here is to load them separately via AJAX. This AJAX request would
call the comments controller and receive a JSON response.

    A good rule of thumb is that you can use a separate module whenever possible
    for functionality that’s orthogonal to your application’s model.
    Code that doesn’t depend on your model can usually be extracted to a
    separate independent module, but code that uses your model shouldn’t be in a
    module because then that module would depend on your application and not be
    reusable.

If you want to extract functionality that appears to depend on the model,
consider whether there’s a way to avoid this dependency, or make it a loose
coupling by using an external reference like the page URL rather than a model
reference like a product ID.

A module can also include a plugin, which is a class that extends
`play.api.Plugin` in order to intercept application startup and shutdown events.
Plugins aren’t specific to modules—a Play application can also include a plugin—
but they’re especially useful for modules that enhance Play.

== HTTP API design ==
=== Routing ===

`GET /products controllers.Products.list(page: Int ?= 1)` syntax is used for
optional parameters.

`GET /products controllers.Products.list(page: Int = 1)` syntax is used for
fixed parameter values that are not specified in the URL.

*To support slashes in URL parameters*, use:
`GET /photo/*file controllers.Media.photo(file: String)` (notice the asterisk).

*To alias routes*, use:
{{{
GET /product/$ean<\d{13}> controllers.Products.details(ean: Long)
GET /product/:alias controllers.Products.alias(alias: String)
}}}

*Reverse routing* is nothing more than having Scala objects built based on the
 route configuration file.
They serve to provide maintainable URL references that reflect any changes in
the configuration.
Each URL of your application shoul optimally occur only once - in the route
config file.

Reverse controllers are available in the `controllers.routes` class, generated
by Play.

=== Response handling ===

You can add custom headers to the response.

Example:
{{{
val url = routes.Products.details(product.ean).url
// /HTTP 201 wuth a 'Location' header
Created.withHeaders(LOCATION -> url)
}}}

Response types can be overriden, using values from the
`play.api.http.ContentTypes` trait, which `Controller` extends.

Example:
{{{
Ok("""{ "status": "success" }""").as(JSON)
}}}

==== JSON ====

JSON responses are created from `Map` objects.

Example:
{{{
def json = Action {
    import play.api.libs.json.Json
    val success = Map("status" -> "success")
    val json = Json.toJson(success)
    Ok(json)
}
}}}

==== Binary data ====

Creating a binary response is similar to JSON or XML - you just need to add the
content type yourself.

==== Session ====

Session data is a `Map[String,String]` which is implemented as an HTTP cookie.

    *Important note:* 
    The canonical use case for session cookies is to identify the currently
    authenticated user. In fact, it’s reasonable to argue that if you can 
    identify the current user using a session cookie, then that should be the
    only thing you use cookies for, because you can load user-specific data from 
    a Persistent data model instead.

Example usage:
{{{
Ok(results).withSession(
    request.session + ("search.previous" -> query)
)

// Then for another request...
val search = request.session.get("search.previous")

// Clearing a session value
Ok(results).withSession(
    request.session - "search.previous"
)
}}}

==== Flash data ====

A specific, transient session use case.
Flash data can be used e.g. to display success/error messages.

To use the _flash scope_ provided by Play:
{{{
// set the flash data
Redirect(routes.Products.flash()).flashing(
    "info" -> "Product deleted!"
)

// (somewhere else) acquire the data
val message = request.flash("info")
}}}

An `(implicit flash: Flash)` parameter can also be used in a view template to
have implicit access to the _flash scope_.



