= Distributed system checklist =

%toc

The following list gives a better idea of what should be considered when designing a distributed system.

== Fault tolerance ==
- What happens when a dependency starts failing? What if it begins failing *slowly*?
- How can the system *degrade* in a graceful manner?
- How does the system react to overload? Is it well-conditioned? (i.e. does it cope well with increased load?)
- What's the worst-case scenario for total failure?
- How quickly can the system recover?
- Is delayable work delayed?
- Is the system as *simple* as possible? Why cannot it be simpler?
- How can the system shed load?
- Which failures can be mitigated and how?
- Which operations may be retried? Are they being retried?

== Scalability ==
- How does the system grow? What is the main metric with which the system scales?
- How does the system scale to multiple datacenters?
- How does demand vary?
- How do you ensure the system is always able to handle peak loads?
- How much query processing is done? Can data be shaped into queries?
- Is the system replicated?

== Operability ==
- How can features be turned on or off?
- How do you monitor the system? How are anomalies detected?
- Does the system have operational needs specific to the application?
- How is the system deployed? How is it deployed in an emergency situation?
- What are the capacity needs? How does the system grow?
- How do you configure the system? How do you do it *quickly*?
- Does the system behave in a predictable manner? Are there nonlinearities in load or failure response? If so, where?

== Efficiency ==
- Is it possible to precompute data?
- Are you doing as little work as possible?
- Is the program as concurrent as possible?
- Does the system make use of work batching?
- Have you profiled the sustem? Is it possible to profile on site?
- Can you load test the system? How do you catch performance regressions?
