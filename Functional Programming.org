* Seminal typeclasses
The typeclasses allowing functional data manipulation are based on that a value is wrapped in a *context*.

- *functors* allow you to apply a function to a wrapped value using =fmap= or =<$>=.
- *applicatives* allow you to apply a wrapped function to a wrapped value using =<*>= or =liftA=.
- *monads* allow you to a function that returns a wrapped value to a wrapped value using =>>== or =liftM=. 

** Functor
When a value is wrapped in a context, you cannot directly apply a function to it.
The Functor typeclass defined an =fmap= function, which unwraps a value from its context, applies a function to it and wraps it back.

#+begin_src ghci
> fmap (+3) (Just 2)
Just 5
> fmap (+3) Nothing
Nothing
#+end_src

This works because =Maybe= is a Functor.
#+begin_src haskell
instance Functor Maybe where
    fmap func (Just val) = Just (func val)
    fmap func Nothing = Nothing
#+end_src

In a language without =Maybe= you would write:

#+begin_src javascript
var post = Post.find_by_id(1);
if (post) return post.title;
else return null;
#+end_src

but in Haskell you get

#+begin_src haskell
fmap (getPostTitle) (findPost 1)
#+end_src

or equivalently

#+begin_src haskell
getPostTitle <$> (findPost 1)
#+end_src

Lists are Functors.

#+begin_src haskell
instance Functor [] where
    fmap = map
#+end_src

As are functions.

#+begin_src haskell
instance Functor ((->) r) where
    fmap f g = f . g 
#+end_src

** Applicative

With an applicative, values are wrapped in a context, but functions are too.
This presents new opportunities.

The =Control.Applicative= module defines an =<*>= operator that knows how to apply wrapped functions to wrapped values.

Examples:

#+begin_src haskell
Just (+3) <*> Just 2 == Just 5
#+end_src

Applying a list of functions to a list.
#+begin_src ghci
> [(*2), (+3)] <*> [1, 2, 3]
[2, 4, 6, 4, 5, 6]
#+end_src

Applicatives are more expressive than Functors in that e.g. you can apply a binary function to two wrapped values:

#+begin_src ghci
> (+) <$> (Just 5)
Just (+5)
> Just (+5) <*> (Just 3)
Just 8
#+end_src

And there is a function for that 

#+begin_src haskell
liftA2 (*) (Just 5) (Just 3)
#+end_src

which is not possible with Functors:

#+begin_src ghci
> (+) <$> (Just 5)
Just (+5)
> Just (+5) <$> (Just 4)
error
#+end_src

** Monad

Functors apply a *function* to a wrapped value.

Applicatives apply a *wrapped function* to a wrapped value.

Monads apply a *function that returns a wrapped value* to a wrapped value.

It is achieved through the /bind/ operator =>>==.

A partial definition of a Monad looks like so.

#+begin_src haskell
class Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
#+end_src

The =>>== operator takes a =Monad a= and a function that knows what to do with its wrapped value, returning a =Monad b=.

An example of the Maybe Monad:
#+begin_src haskell
instance Monad Maybe where
    Nothing >>= func = Nothing
    Just val >>= func  = func val -- here, the m a -> a stripping occurs.
#+end_src


See that Maybe is a Functor, an Applicative *and* a Monad.

*** IO Monad

*getLine* takes no args and gets user input.

#+begin_src haskell
getLine :: IO String
#+end_src

*readFile* takes a file path and returns its contents as a string.

#+begin_src haskell
readFile :: FilePath -> IO String
#+end_src

*putStrLn* takes a string and prints it.

#+begin_src haskell
putStrLn :: String -> IO ()
#+end_src

The neat thing is that these functions can be chained. 
To print out contents of a file with path given as user input:

#+begin_src haskell
getline >>= readFile >>= putStrLn
#+end_src

Also, there is the =do= notation to sugar-coat the bindings:

#+begin_src haskell
result = do
    filename <- getLine
    contents <- readFile
    putStrLn contents
#+end_src

*** Writer Monad

Example case: halving with logs.

#+begin_src haskell
half x = (x `div` 2, "I just halved " ++ (show x) ++ "!")
#+end_src

What we need to do to have the logs concatenated nicely:
#+begin_src haskell
finalValue = (val2, log1 ++ log2)
    where (val1, log1) = half 8
          (val2, log2) = half val1
#+end_src

What we want: 

#+begin_src haskell
half . half $ 8
#+end_src

Every writer has a log and a value.

#+begin_src haskell
data Writer w a = Writer { runWriter :: (a, w) }  
#+end_src



