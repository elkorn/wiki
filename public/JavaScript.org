#+FILETAGS: :vimwiki:

* JavaScript
#= Web - JavaScript =

[[WellManagedAMDCodebase]]

[[MVCFrameworks]]

[[ReactIsNotAsGoodAsItCouldBe]]



** WellManagedAMDCodebase
*** Well managed AMD codebase

Such a codebase is characterized by 5 traits.

**** 1. Dependencies are always declared

Scripts should not assume that a dependency will be available in the target environment e.g. a jQuery plugin should not assume jQuery being present.
Instead, all dependencies should be explicitly stated in the module definition.

**** 2. 3rd party code is shimmed

If a 3rd-party module implicitly depends on some module and is not AMD-oriented, the dependencies have to be made explicit by using a shim.
Example:
#+begin_example
var require = {
    shim: {
        "lib/cool-plugin": {
            deps: ["lib/jquery"]
        }
    }
}
#+end_example

**** 3. Definitions are separate from executions

This trait improves testability and reusability.
The problem occurs when a `define` call not only defines a module but also invokes it.
This causes unavoidable side effects and makes mocking harder.

The solution is to use separate `define` statements for actual definition and execution.
Example:
#+begin_example
## js/User.js
define(function(require) {
    var User = function(name, greeter) {
        this.name = name;
        this.greeter = greeter;
    };

    User.prototype.sayHello = function() {
        this.greeter('Hello ' + this.name);
    };

    return User;
});

## js/page.js
define(function(require) {
    var User = require('js/User');
    var user = new User('Alice', window.alert);
    
    user.sayHello();
});
#+end_example

**** 4. Dependency loading is asynchronous

Require.js enables asynchronous loading by default when the module is placed in a function.
It gets invoked only after all dependencies are met.
#+begin_example
define(['lib/jquery', 'lib/underscore'], function($,_) {
    'use strict';
    // init
});
#+end_example

**** 5. Modules do not depend on globals.

Instead of using globals, create a module with important constants and so on.
3rd-party globals can be shimmed:
#+begin_example
// Calc is global, but we export it as a local variable when it's required.
var require = {
    shim: {
        'lib/calculator': {
            export: "Calc"
        }
    }
};
#+end_example
** MVCFrameworks
*** MVC Frameworks

**** Mithril
http://lhorie.github.io/mithril/

It has virtual DOM.

**** Taunus
http://taunus.bevacqua.io/

Performance-oriented.

**** Mercury
https://github.com/Raynos/mercury

Very modular, has virtual DOM.

**** Maria
https://github.com/petermichaux/maria

Implements the smalltalk MVC model.
** ReactIsNotAsGoodAsItCouldBe
*** React is not as good as it could be

Via "Don't React" presentation.

Don't follow the hype, the community, the companies.
The only thing you should follow is the science.

React has virtual DOM.
That's good, since the real DOM is very slow.

Unfortunately, the authors did not quite grasp the idea of reactive programming.
Their docs mention 'reactive data flow' or 'reactive state' - things that do not exist.

There are two ways of communicating:
**** interactive communication, where a module defines what it affects
**** reactive communication, where a module defines what it is affected by

In interavtive programming, there are 2 key roles:
**** passive, where methods are being exposed to mutate internal state (this is bad)
**** proactive, where the only communication responsibilities are sending and handling events (this is good).


React has mostly a passive API, especially the `state` concepts.

It could be improved by:
**** promoting virtual DOM to first-class data structures
**** making it fully proactive
**** making it more explicit - less magic

**** Alternatives
Virtual DOM libraries:
***** https://github.com/Matt-Esch/virtual-dom
***** https://github.com/staltz/cycle

Better frameworks: check [[MVCFrameworks]].
