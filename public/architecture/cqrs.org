* CQRS characteristics

At the core, CQRS is a notion of using different models for updating and reading information.

Nowadays, a lot of applications handle reads and writes by a domain model in the backend.
This model is often anemic, having entities serving as just DTOs and services used only to move them around.
Repository interfaces often house reads and writes, intermixed.

On top of that, read and write operations are different in terms of non-functional requirements.

- Reads are much more prevalent than writes.
- When reading data, most frequently we want to read a complex structure, or a lot of data. Writes are generally affecting a limited set of data.
- Reads do not change any state, writes do.
- Read operations need to be as fast as possible, writes are treated with more lenience in this matter.

** Reading 

To maintain speed, data needs to be accessed with as few DB queries as possible.
No business logic should be executed while retrieving data, because no modifications should occur.
Derived data should be pre-calculated - the system should work in a 'push' manner.

** Writing

Write commands directly represent events that are incoming to the system (e.g. adding a product to a shopping cart).
They do not return any data other than a status or a message informing the sender about a success or failure.
   
** Implementation

CQRS can be implemented very cleanly with the help of Event Sourcing.

Events are generated by the domain as a result of commands that change state.
They are written to an event store.

Queries get their data from a read model. 
The read model is separate from the event store and eventually consistent with it.
It consists of a document database with a possible file-based full text index (or something of the ilk).

The read model is being populated from the write model by an asynchronous dispatcher.
This dispatcher runs in the background and dispatches events to observers which contain the logic for building up the read model.

